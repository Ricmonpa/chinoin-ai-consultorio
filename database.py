# -*- coding: utf-8 -*-
import sqlite3
import os
from datetime import datetime
from typing import List, Dict, Optional

class ConsultaDB:
    def __init__(self, db_path: str = "consultas.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Inicializa la base de datos y crea las tablas necesarias"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS consultas (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    fecha_consulta DATETIME DEFAULT CURRENT_TIMESTAMP,
                    medico_id TEXT DEFAULT 'default',
                    paciente_nombre TEXT,
                    transcripcion TEXT NOT NULL,
                    soap_subjetivo TEXT,
                    soap_objetivo TEXT,
                    soap_analisis TEXT,
                    soap_plan TEXT,
                    diagnostico TEXT,
                    tratamiento TEXT,
                    cumplimiento_estado TEXT,
                    audio_duracion INTEGER,
                    notas_adicionales TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Índices para búsquedas rápidas
            conn.execute('CREATE INDEX IF NOT EXISTS idx_fecha ON consultas(fecha_consulta)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_medico ON consultas(medico_id)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_diagnostico ON consultas(diagnostico)')
            
            conn.commit()
    
    def guardar_consulta(self, consulta_data: Dict) -> int:
        """Guarda una nueva consulta y retorna el ID"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute('''
                INSERT INTO consultas (
                    medico_id, paciente_nombre, transcripcion,
                    soap_subjetivo, soap_objetivo, soap_analisis, soap_plan,
                    diagnostico, tratamiento, cumplimiento_estado,
                    audio_duracion, notas_adicionales
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                consulta_data.get('medico_id', 'default'),
                consulta_data.get('paciente_nombre', ''),
                consulta_data.get('transcripcion', ''),
                consulta_data.get('soap_subjetivo', ''),
                consulta_data.get('soap_objetivo', ''),
                consulta_data.get('soap_analisis', ''),
                consulta_data.get('soap_plan', ''),
                consulta_data.get('diagnostico', ''),
                consulta_data.get('tratamiento', ''),
                consulta_data.get('cumplimiento_estado', ''),
                consulta_data.get('audio_duracion', 0),
                consulta_data.get('notas_adicionales', '')
            ))
            return cursor.lastrowid
    
    def obtener_consultas(self, medico_id: str = 'default', limite: int = 50) -> List[Dict]:
        """Obtiene las consultas más recientes de un médico"""
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.execute('''
                SELECT * FROM consultas 
                WHERE medico_id = ? 
                ORDER BY fecha_consulta DESC 
                LIMIT ?
            ''', (medico_id, limite))
            
            return [dict(row) for row in cursor.fetchall()]
    
    def obtener_consulta(self, consulta_id: int) -> Optional[Dict]:
        """Obtiene una consulta específica por ID"""
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.execute('SELECT * FROM consultas WHERE id = ?', (consulta_id,))
            row = cursor.fetchone()
            return dict(row) if row else None
    
    def actualizar_consulta(self, consulta_id: int, datos: Dict) -> bool:
        """Actualiza una consulta existente"""
        campos = []
        valores = []
        
        for campo, valor in datos.items():
            if campo in ['soap_subjetivo', 'soap_objetivo', 'soap_analisis', 'soap_plan', 
                        'diagnostico', 'tratamiento', 'notas_adicionales', 'paciente_nombre']:
                campos.append(f"{campo} = ?")
                valores.append(valor)
        
        if not campos:
            return False
        
        campos.append("updated_at = CURRENT_TIMESTAMP")
        valores.append(consulta_id)
        
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(f'''
                UPDATE consultas 
                SET {', '.join(campos)}
                WHERE id = ?
            ''', valores)
            return cursor.rowcount > 0
    
    def buscar_consultas(self, termino: str, medico_id: str = 'default') -> List[Dict]:
        """Busca consultas por término en transcripción, diagnóstico o notas SOAP"""
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.execute('''
                SELECT * FROM consultas 
                WHERE medico_id = ? AND (
                    transcripcion LIKE ? OR 
                    diagnostico LIKE ? OR 
                    soap_subjetivo LIKE ? OR 
                    soap_analisis LIKE ?
                )
                ORDER BY fecha_consulta DESC
            ''', (medico_id, f'%{termino}%', f'%{termino}%', f'%{termino}%', f'%{termino}%'))
            
            return [dict(row) for row in cursor.fetchall()]
    
    def obtener_estadisticas(self, medico_id: str = 'default') -> Dict:
        """Obtiene estadísticas básicas de consultas"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute('''
                SELECT 
                    COUNT(*) as total_consultas,
                    COUNT(DISTINCT DATE(fecha_consulta)) as dias_activos,
                    AVG(audio_duracion) as duracion_promedio
                FROM consultas 
                WHERE medico_id = ?
            ''', (medico_id,))
            
            stats = cursor.fetchone()
            
            # Top 5 diagnósticos más frecuentes
            cursor = conn.execute('''
                SELECT diagnostico, COUNT(*) as frecuencia
                FROM consultas 
                WHERE medico_id = ? AND diagnostico != ''
                GROUP BY diagnostico
                ORDER BY frecuencia DESC
                LIMIT 5
            ''', (medico_id,))
            
            top_diagnosticos = cursor.fetchall()
            
            return {
                'total_consultas': stats[0] or 0,
                'dias_activos': stats[1] or 0,
                'duracion_promedio': round(stats[2] or 0, 1),
                'top_diagnosticos': [{'diagnostico': d[0], 'frecuencia': d[1]} for d in top_diagnosticos]
            }
    
    def eliminar_consulta(self, consulta_id: int) -> bool:
        """Elimina una consulta (usar con cuidado)"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute('DELETE FROM consultas WHERE id = ?', (consulta_id,))
            return cursor.rowcount > 0

class TransaccionDB:
    """Gestión de transacciones financieras (ingresos y gastos) para el módulo del contador"""
    
    def __init__(self, db_path: str = "consultas.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Inicializa las tablas de transacciones financieras"""
        with sqlite3.connect(self.db_path) as conn:
            # Tabla de transacciones (ingresos y gastos)
            conn.execute('''
                CREATE TABLE IF NOT EXISTS transacciones (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    medico_id TEXT DEFAULT 'default',
                    tipo TEXT NOT NULL CHECK(tipo IN ('ingreso', 'gasto')),
                    fecha DATE NOT NULL,
                    monto REAL NOT NULL,
                    concepto TEXT NOT NULL,
                    proveedor TEXT,
                    cfdi_uuid TEXT,
                    cfdi_xml_path TEXT,
                    cfdi_pdf_path TEXT,
                    cfdi_vigente BOOLEAN DEFAULT 1,
                    clasificacion_ia TEXT,
                    clasificacion_contador TEXT,
                    deducible_porcentaje INTEGER DEFAULT 0,
                    estatus_validacion TEXT DEFAULT 'pendiente' CHECK(estatus_validacion IN ('pendiente', 'aprobado', 'rechazado', 'ajustado')),
                    notas_contador TEXT,
                    metodo_pago TEXT,
                    forma_pago TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    validado_por TEXT,
                    validado_at DATETIME
                )
            ''')
            
            # Tabla de reglas de clasificación aprendidas
            conn.execute('''
                CREATE TABLE IF NOT EXISTS reglas_clasificacion (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    medico_id TEXT DEFAULT 'default',
                    patron_concepto TEXT NOT NULL,
                    proveedor TEXT,
                    clasificacion TEXT NOT NULL,
                    deducible_porcentaje INTEGER DEFAULT 0,
                    frecuencia_uso INTEGER DEFAULT 1,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Índices para búsquedas rápidas
            conn.execute('CREATE INDEX IF NOT EXISTS idx_trans_fecha ON transacciones(fecha)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_trans_tipo ON transacciones(tipo)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_trans_estatus ON transacciones(estatus_validacion)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_trans_medico ON transacciones(medico_id)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_reglas_medico ON reglas_clasificacion(medico_id)')
            
            conn.commit()
    
    def guardar_transaccion(self, transaccion_data: Dict) -> int:
        """Guarda una nueva transacción"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute('''
                INSERT INTO transacciones (
                    medico_id, tipo, fecha, monto, concepto, proveedor,
                    cfdi_uuid, cfdi_xml_path, cfdi_pdf_path, cfdi_vigente,
                    clasificacion_ia, deducible_porcentaje, metodo_pago, forma_pago
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                transaccion_data.get('medico_id', 'default'),
                transaccion_data.get('tipo'),
                transaccion_data.get('fecha'),
                transaccion_data.get('monto'),
                transaccion_data.get('concepto'),
                transaccion_data.get('proveedor', ''),
                transaccion_data.get('cfdi_uuid', ''),
                transaccion_data.get('cfdi_xml_path', ''),
                transaccion_data.get('cfdi_pdf_path', ''),
                transaccion_data.get('cfdi_vigente', 1),
                transaccion_data.get('clasificacion_ia', ''),
                transaccion_data.get('deducible_porcentaje', 0),
                transaccion_data.get('metodo_pago', ''),
                transaccion_data.get('forma_pago', '')
            ))
            return cursor.lastrowid
    
    def obtener_transacciones(self, filtros: Dict = None, limite: int = 100) -> List[Dict]:
        """Obtiene transacciones con filtros opcionales"""
        query = 'SELECT * FROM transacciones WHERE medico_id = ?'
        params = [filtros.get('medico_id', 'default') if filtros else 'default']
        
        if filtros:
            if filtros.get('tipo'):
                query += ' AND tipo = ?'
                params.append(filtros['tipo'])
            if filtros.get('estatus_validacion'):
                query += ' AND estatus_validacion = ?'
                params.append(filtros['estatus_validacion'])
            if filtros.get('fecha_desde'):
                query += ' AND fecha >= ?'
                params.append(filtros['fecha_desde'])
            if filtros.get('fecha_hasta'):
                query += ' AND fecha <= ?'
                params.append(filtros['fecha_hasta'])
            if filtros.get('clasificacion'):
                query += ' AND (clasificacion_ia = ? OR clasificacion_contador = ?)'
                params.extend([filtros['clasificacion'], filtros['clasificacion']])
            if filtros.get('cfdi_uuid'):
                query += ' AND cfdi_uuid = ?'
                params.append(filtros['cfdi_uuid'])
        
        query += ' ORDER BY fecha DESC LIMIT ?'
        params.append(limite)
        
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.execute(query, params)
            return [dict(row) for row in cursor.fetchall()]
    
    def validar_transaccion(self, transaccion_id: int, validacion_data: Dict) -> bool:
        """Valida una transacción (aprueba, rechaza o ajusta)"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute('''
                UPDATE transacciones 
                SET estatus_validacion = ?,
                    clasificacion_contador = ?,
                    deducible_porcentaje = ?,
                    notas_contador = ?,
                    validado_por = ?,
                    validado_at = CURRENT_TIMESTAMP,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
            ''', (
                validacion_data.get('estatus', 'aprobado'),
                validacion_data.get('clasificacion', ''),
                validacion_data.get('deducible_porcentaje', 0),
                validacion_data.get('notas', ''),
                validacion_data.get('validado_por', 'contador'),
                transaccion_id
            ))
            
            # Si se aprueba, aprender la regla
            if validacion_data.get('estatus') == 'aprobado' and validacion_data.get('clasificacion'):
                self._aprender_regla(transaccion_id, validacion_data)
            
            return cursor.rowcount > 0
    
    def _aprender_regla(self, transaccion_id: int, validacion_data: Dict):
        """Aprende una regla de clasificación basada en la validación del contador"""
        with sqlite3.connect(self.db_path) as conn:
            # Obtener la transacción
            cursor = conn.execute('SELECT concepto, proveedor, medico_id FROM transacciones WHERE id = ?', (transaccion_id,))
            trans = cursor.fetchone()
            if not trans:
                return
            
            concepto, proveedor, medico_id = trans
            
            # Verificar si ya existe una regla similar
            cursor = conn.execute('''
                SELECT id, frecuencia_uso FROM reglas_clasificacion 
                WHERE medico_id = ? AND patron_concepto = ? AND proveedor = ?
            ''', (medico_id, concepto, proveedor or ''))
            
            regla_existente = cursor.fetchone()
            
            if regla_existente:
                # Incrementar frecuencia
                conn.execute('''
                    UPDATE reglas_clasificacion 
                    SET frecuencia_uso = frecuencia_uso + 1,
                        clasificacion = ?,
                        deducible_porcentaje = ?,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE id = ?
                ''', (validacion_data['clasificacion'], validacion_data.get('deducible_porcentaje', 0), regla_existente[0]))
            else:
                # Crear nueva regla
                conn.execute('''
                    INSERT INTO reglas_clasificacion (
                        medico_id, patron_concepto, proveedor, clasificacion, deducible_porcentaje
                    ) VALUES (?, ?, ?, ?, ?)
                ''', (medico_id, concepto, proveedor or '', validacion_data['clasificacion'], validacion_data.get('deducible_porcentaje', 0)))
            
            conn.commit()
    
    def clasificar_con_ia(self, concepto: str, proveedor: str = '', medico_id: str = 'default') -> Dict:
        """Clasifica una transacción usando reglas aprendidas"""
        with sqlite3.connect(self.db_path) as conn:
            # Buscar regla exacta
            cursor = conn.execute('''
                SELECT clasificacion, deducible_porcentaje, frecuencia_uso
                FROM reglas_clasificacion 
                WHERE medico_id = ? AND patron_concepto = ? AND proveedor = ?
                ORDER BY frecuencia_uso DESC
                LIMIT 1
            ''', (medico_id, concepto, proveedor))
            
            regla = cursor.fetchone()
            
            if regla:
                return {
                    'clasificacion': regla[0],
                    'deducible_porcentaje': regla[1],
                    'confianza': 'alta',
                    'metodo': 'regla_aprendida'
                }
            
            # Buscar regla por similitud de concepto
            cursor = conn.execute('''
                SELECT clasificacion, deducible_porcentaje, frecuencia_uso
                FROM reglas_clasificacion 
                WHERE medico_id = ? AND (
                    patron_concepto LIKE ? OR ? LIKE patron_concepto
                )
                ORDER BY frecuencia_uso DESC
                LIMIT 1
            ''', (medico_id, f'%{concepto}%', f'%{concepto}%'))
            
            regla_similar = cursor.fetchone()
            
            if regla_similar:
                return {
                    'clasificacion': regla_similar[0],
                    'deducible_porcentaje': regla_similar[1],
                    'confianza': 'media',
                    'metodo': 'similitud'
                }
            
            # Sin regla, usar clasificación por defecto
            return {
                'clasificacion': 'Sin clasificar',
                'deducible_porcentaje': 0,
                'confianza': 'baja',
                'metodo': 'default'
            }
    
    def obtener_estadisticas_financieras(self, medico_id: str = 'default', fecha_desde: str = None, fecha_hasta: str = None) -> Dict:
        """Obtiene estadísticas financieras para el dashboard del contador"""
        with sqlite3.connect(self.db_path) as conn:
            query_base = 'SELECT tipo, SUM(monto) as total FROM transacciones WHERE medico_id = ?'
            params = [medico_id]
            
            if fecha_desde:
                query_base += ' AND fecha >= ?'
                params.append(fecha_desde)
            if fecha_hasta:
                query_base += ' AND fecha <= ?'
                params.append(fecha_hasta)
            
            query_base += ' GROUP BY tipo'
            
            cursor = conn.execute(query_base, params)
            totales = {row[0]: row[1] for row in cursor.fetchall()}
            
            # Transacciones pendientes de validación
            cursor = conn.execute('''
                SELECT COUNT(*) FROM transacciones 
                WHERE medico_id = ? AND estatus_validacion = 'pendiente'
            ''', (medico_id,))
            pendientes = cursor.fetchone()[0]
            
            # Top gastos deducibles
            cursor = conn.execute('''
                SELECT clasificacion_contador, SUM(monto * deducible_porcentaje / 100.0) as monto_deducible
                FROM transacciones 
                WHERE medico_id = ? AND tipo = 'gasto' AND estatus_validacion = 'aprobado'
                GROUP BY clasificacion_contador
                ORDER BY monto_deducible DESC
                LIMIT 5
            ''', (medico_id,))
            top_deducibles = [{'clasificacion': row[0], 'monto': row[1]} for row in cursor.fetchall()]
            
            return {
                'ingresos_totales': totales.get('ingreso', 0),
                'gastos_totales': totales.get('gasto', 0),
                'utilidad': totales.get('ingreso', 0) - totales.get('gasto', 0),
                'pendientes_validacion': pendientes,
                'top_deducibles': top_deducibles
            }

class SeguroDB:
    """Gestión de datos de seguros médicos (credenciales, tabuladores, informes)"""
    
    def __init__(self, db_path: str = "consultas.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Inicializa las tablas de seguros"""
        with sqlite3.connect(self.db_path) as conn:
            # Tabla de credenciales de seguro procesadas
            conn.execute('''
                CREATE TABLE IF NOT EXISTS credenciales_seguros (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    medico_id TEXT DEFAULT 'default',
                    paciente_id INTEGER,
                    paciente_nombre TEXT,
                    aseguradora TEXT NOT NULL,
                    numero_poliza TEXT NOT NULL,
                    plan_nombre TEXT,
                    nivel_hospitalario TEXT,
                    deducible_estimado REAL,
                    coaseguro_porcentaje REAL,
                    hospitales_red TEXT,
                    imagen_path TEXT,
                    datos_extractos TEXT,
                    fecha_procesamiento DATETIME DEFAULT CURRENT_TIMESTAMP,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Tabla de tabuladores cargados (PDFs)
            conn.execute('''
                CREATE TABLE IF NOT EXISTS tabuladores (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    aseguradora TEXT NOT NULL,
                    plan_nombre TEXT,
                    tipo_documento TEXT CHECK(tipo_documento IN ('tabulador', 'condiciones_generales')),
                    archivo_path TEXT NOT NULL,
                    archivo_hash TEXT,
                    fecha_vigencia DATE,
                    contenido_texto TEXT,
                    contenido_embedding TEXT,
                    fecha_carga DATETIME DEFAULT CURRENT_TIMESTAMP,
                    activo BOOLEAN DEFAULT 1
                )
            ''')
            
            # Tabla de informes médicos generados
            conn.execute('''
                CREATE TABLE IF NOT EXISTS informes_medicos (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    consulta_id INTEGER,
                    credencial_seguro_id INTEGER,
                    aseguradora TEXT NOT NULL,
                    paciente_nombre TEXT,
                    numero_poliza TEXT,
                    diagnostico TEXT,
                    procedimiento TEXT,
                    codigo_cpt TEXT,
                    codigo_cie10 TEXT,
                    informe_pdf_path TEXT,
                    fecha_generacion DATETIME DEFAULT CURRENT_TIMESTAMP,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Tabla de consultas de honorarios (búsquedas en tabuladores)
            conn.execute('''
                CREATE TABLE IF NOT EXISTS consultas_honorarios (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    medico_id TEXT DEFAULT 'default',
                    aseguradora TEXT,
                    plan_nombre TEXT,
                    procedimiento TEXT,
                    codigo_cpt TEXT,
                    monto_encontrado REAL,
                    fuente_tabulador_id INTEGER,
                    fecha_consulta DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Índices
            conn.execute('CREATE INDEX IF NOT EXISTS idx_credencial_aseguradora ON credenciales_seguros(aseguradora)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_credencial_poliza ON credenciales_seguros(numero_poliza)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_credencial_paciente ON credenciales_seguros(paciente_id)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_tabulador_aseguradora ON tabuladores(aseguradora)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_tabulador_activo ON tabuladores(activo)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_informe_consulta ON informes_medicos(consulta_id)')
            
            conn.commit()
    
    def guardar_credencial(self, credencial_data: Dict) -> int:
        """Guarda una credencial de seguro procesada"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute('''
                INSERT INTO credenciales_seguros (
                    medico_id, paciente_id, paciente_nombre,
                    aseguradora, numero_poliza, plan_nombre, nivel_hospitalario,
                    deducible_estimado, coaseguro_porcentaje, hospitales_red,
                    imagen_path, datos_extractos
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                credencial_data.get('medico_id', 'default'),
                credencial_data.get('paciente_id'),
                credencial_data.get('paciente_nombre', ''),
                credencial_data.get('aseguradora', ''),
                credencial_data.get('numero_poliza', ''),
                credencial_data.get('plan_nombre', ''),
                credencial_data.get('nivel_hospitalario', ''),
                credencial_data.get('deducible_estimado'),
                credencial_data.get('coaseguro_porcentaje'),
                credencial_data.get('hospitales_red', ''),
                credencial_data.get('imagen_path', ''),
                credencial_data.get('datos_extractos', '')
            ))
            return cursor.lastrowid
    
    def obtener_credencial(self, credencial_id: int) -> Optional[Dict]:
        """Obtiene una credencial por ID"""
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.execute('SELECT * FROM credenciales_seguros WHERE id = ?', (credencial_id,))
            row = cursor.fetchone()
            return dict(row) if row else None
    
    def obtener_credenciales(self, medico_id: str = 'default', limite: int = 50) -> List[Dict]:
        """Obtiene las credenciales más recientes"""
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.execute('''
                SELECT * FROM credenciales_seguros 
                WHERE medico_id = ?
                ORDER BY fecha_procesamiento DESC 
                LIMIT ?
            ''', (medico_id, limite))
            return [dict(row) for row in cursor.fetchall()]
    
    def guardar_tabulador(self, tabulador_data: Dict) -> int:
        """Guarda información de un tabulador PDF cargado"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute('''
                INSERT INTO tabuladores (
                    aseguradora, plan_nombre, tipo_documento,
                    archivo_path, archivo_hash, fecha_vigencia,
                    contenido_texto, contenido_embedding
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                tabulador_data.get('aseguradora', ''),
                tabulador_data.get('plan_nombre', ''),
                tabulador_data.get('tipo_documento', 'tabulador'),
                tabulador_data.get('archivo_path', ''),
                tabulador_data.get('archivo_hash', ''),
                tabulador_data.get('fecha_vigencia'),
                tabulador_data.get('contenido_texto', ''),
                tabulador_data.get('contenido_embedding', '')
            ))
            return cursor.lastrowid
    
    def obtener_tabuladores(self, aseguradora: str = None, activo: bool = True) -> List[Dict]:
        """Obtiene tabuladores, filtrados opcionalmente por aseguradora"""
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            query = 'SELECT * FROM tabuladores WHERE activo = ?'
            params = [1 if activo else 0]
            
            if aseguradora:
                query += ' AND aseguradora = ?'
                params.append(aseguradora)
            
            query += ' ORDER BY fecha_carga DESC'
            cursor = conn.execute(query, params)
            return [dict(row) for row in cursor.fetchall()]
    
    def guardar_informe_medico(self, informe_data: Dict) -> int:
        """Guarda un informe médico generado"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute('''
                INSERT INTO informes_medicos (
                    consulta_id, credencial_seguro_id, aseguradora,
                    paciente_nombre, numero_poliza, diagnostico,
                    procedimiento, codigo_cpt, codigo_cie10, informe_pdf_path
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                informe_data.get('consulta_id'),
                informe_data.get('credencial_seguro_id'),
                informe_data.get('aseguradora', ''),
                informe_data.get('paciente_nombre', ''),
                informe_data.get('numero_poliza', ''),
                informe_data.get('diagnostico', ''),
                informe_data.get('procedimiento', ''),
                informe_data.get('codigo_cpt', ''),
                informe_data.get('codigo_cie10', ''),
                informe_data.get('informe_pdf_path', '')
            ))
            return cursor.lastrowid
    
    def guardar_consulta_honorario(self, consulta_data: Dict) -> int:
        """Guarda una consulta de honorario realizada"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute('''
                INSERT INTO consultas_honorarios (
                    medico_id, aseguradora, plan_nombre,
                    procedimiento, codigo_cpt, monto_encontrado, fuente_tabulador_id
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (
                consulta_data.get('medico_id', 'default'),
                consulta_data.get('aseguradora', ''),
                consulta_data.get('plan_nombre', ''),
                consulta_data.get('procedimiento', ''),
                consulta_data.get('codigo_cpt', ''),
                consulta_data.get('monto_encontrado'),
                consulta_data.get('fuente_tabulador_id')
            ))
            return cursor.lastrowid